# 垃圾回收、内存泄漏

## 垃圾回收
> JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。

## 垃圾回收算法

### 引用计数
> 这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。
```
  var o = {
    a: {
      b:2
    }
  };
  // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o
  // 很显然，没有一个可以被垃圾收集


  var o2 = o; // o2 变量是第二个对“这个对象”的引用

  o = 1;      // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有

  var oa = o2.a; // 引用“这个对象”的 a 属性
                // 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa

  o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
            // 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收

  oa = null; // a 属性的那个对象现在也是零引用了
            // 它可以被垃圾回收了

```
> 该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
```
  function f() {
    var o = {};
    var o2 = {};
    o.a = o2; // o 引用 o2
    o2.a = o; // o2 引用 o

    return "azerty";
  }

  f();

```

### 标记清除
> 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的活动对象和收集所有不能获得的非活动对象。
- 活动对象:能通过引用程序引用的对象就被称为活动对象。（可以直接或间接从全局变量空间中引出的对象）
- 非活动对象:不能通过程序引用的对象呗称为非活动对象。（这就是被清除的目标）

> 算法由标记阶段和清除阶段构成。在标记阶段会把所有的活动对象都做上标记，然后在清除阶段会把没有标记的对象，也就是非活动对象回收。

#### 标记阶段
> 标记阶段就是遍历对象并标记的处理过程。

#### 清除阶段
> 遍历整个堆，回收没有打上标记的对象（垃圾），使其能再次利用。


> 这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。

> 限制：那些无法从根对象查询到的对象都将被清除。尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。

### 手动回收
- 数组：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会分配一个空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
- object：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。

### 内存泄漏
> 不再用到的内存，没有及时释放，就叫做内存泄漏。
- 意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。如果需要全局变量来存储很多数据，必须确保在使用过后将它设置为null或重新为他赋值。
  ```
    function fun() {
      bar = 'test'
    }
    function fun2() {
      this.bar = 'test'
    }
    // bar是一个全局变量
  ```
  解决方法：
  - 避免创建全局变量
  - 使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 use strict
  
- 闭包：由于生成了闭包造成父级词法环境组件中被访问变量不被释放
  ```
    function fn () {
      var a = "hello"
      return function () {
        console.log(a)
      }
    }
  ```
  解决方法：
  - 手动回收，赋值变量为null
  - 不使用闭包

- 没有清理的DOM元素引用：虽然在某个地方删除了元素，但是对象中还存在对dom的引用。
  ```
    // 在对象中引用DOM
    var elements = {
      btn: document.getElementById('btn'),
    }
    function doSomeThing() {
      elements.btn.click()
    }

    function removeBtn() {
      // 将body中的btn移除, 也就是移除 DOM树中的btn
      document.body.removeChild(document.getElementById('btn'))
      // 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被回收
    }
  ```
  解决方法：
  - 手动回收，elements.btn = null

- 被遗忘的定时器和回调：定时器没有手动注销的话。定时器会一直存在。造成定时器中回调函数引用的变量不被释放。只要js中还存在对元素的引用，元素和事件都还是存在内存中的。
  ```
    // 定时器 loadData例为请求数据函数
    var serverData = loadData()
    setInterval(function () {
      var renderer = document.getElementById('renderer')
      if (renderer) {
        renderer.innerHTML = JSON.stringify(serverData)
      }
    }, 5000)

    // 观察者模式
    var btn = document.getElementById('btn')
    function onClick(element) {
      element.innerHTMl = "innerHTML"
    }
    btn.addEventListener('click', onClick)
  ```
  解决方法：
  - 手动删除定时器和 dom
  - removeEventListener 移除事件监听

### [内存泄漏排查](https://juejin.cn/post/6844904019983335438#comment)
> 借助谷歌devtools调试工具中的memory面板进行分析
> [参考文档：https://juejin.cn/post/6844904019983335438#comment](https://juejin.cn/post/6844904019983335438#comment)
> [参考文档：https://juejin.cn/post/6844903934235148296#comment](https://juejin.cn/post/6844903934235148296#comment)



