# [你的程序中可能存在内存泄漏](https://juejin.cn/post/6984188410659340324)

## 什么是内存泄漏
浏览器引擎中是有垃圾回收机制的，它主要针对一些程序中不再使用的对象，对其清理并回收释放掉所占用的内存。
那么垃圾回收机制会把不再使用的对象（垃圾）全都回收掉吗？
其实浏览器引擎虽然针对垃圾回收做的了各种优化从而尽可能确保垃圾得以回收，但并不是说我们就可以完全不用关心这块了，我们的代码中应该要主动避免一些不利于引擎做垃圾回收的操作，因为不是所有无用对象内存都可以被回收的，**`当不再用到的对象内存，没有及时被回收时，我们叫它内存泄漏（Memory leak）。内存泄露因为会减少可用内存从而降低计算机性能，严重的可能导致设备停止正常工作，或者应用程序崩溃。`** 

## 垃圾回收
垃圾回收和内存泄漏是因果关系，如果垃圾都被回收了那么就不存在内存泄漏，有垃圾没被回收就会造成内存泄漏。
- 什么是垃圾回收机制？
程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而垃圾回收就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，过程是相对比较无感的，这一套由引擎执行而对我们又相对无感的操作也就是常说的`垃圾回收机制`了。

- 垃圾是怎样产生的？为什么要进行垃圾回收？
我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存。用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。

- 垃圾回收是怎样进行的？
JavaScript 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存，然后将其释放掉，基于此介绍最常见的两种垃圾回收策略
1. **标记清除算法**
   此算法分为`标记`和`清除`两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。 
   整个标记清除算法大致过程就像下面这样
   - 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
   - 然后从各个根对象（所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树 等）开始遍历，把不是垃圾的标记改为1
   - 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
   - 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收
  
    这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。

    > `限制`：那些无法从根对象查询到的对象都将被清除。尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。

    > `缺点`：标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，出现了`内存碎片`，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题。假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配
    - 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
    - 分配策略
      - First-fit，找到大于等于 size 的块立即返回
      - Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
      - Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回
    - 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
    ![内存碎片](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
    ![内存分配](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/fb5107f04a3249ce8d37ec7cc5fd9668~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
    > 标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存
    
    ![标记整理](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
  
2. **引用计数算法**
   它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下
   它的策略是跟踪记录每个变量值被使用的次数
   ```
      var o = {
        a: {
          b:2
        }
      };
      // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o
      // 很显然，没有一个可以被垃圾收集


      var o2 = o; // o2 变量是第二个对“这个对象”的引用

      o = 1;      // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有

      var oa = o2.a; // 引用“这个对象”的 a 属性
                    // 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa

      o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
                // 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收

      oa = null; // a 属性的那个对象现在也是零引用了
                // 它可以被垃圾回收了

    ```
   - 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
   - 如果同一个值又被赋给另一个变量，那么引用数加 1
   - 如果该变量的值被其他的值覆盖了，则引用次数减 1
   - 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
  
   该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
    ```
      function f() {
        var o = {};
        var o2 = {};
        o.a = o2; // o 引用 o2
        o2.a = o; // o2 引用 o

        return "azerty";
      }

      f();

    ```
[V8 引擎对垃圾回收进行了哪些优化？点击查看参考文档](https://juejin.cn/post/6981588276356317214)

### 手动回收
- 数组：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会分配一个空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
- object：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。

## 常见的内存泄漏
- [不正当的闭包](./closure.html)
  > [闭包](https://blog.csdn.net/m0_49662897/article/details/127628629)：是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。
- [隐式全局变量](./global-variable.html)
  > 函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。但是对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以全局变量通常不会被回收，我们使用全局变量是 OK 的，但同时我们要避免一些额外的全局变量产生
- [游离 DOM 引用](./dom.html)
  > 我们在代码中使用 DOM 时会使用变量缓存 DOM 节点的引用，但移除节点的时候，我们应该同步释放缓存的引用，否则游离的子树无法释放。
- [遗忘的定时器](./timer.html)
  > 当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。
- [遗忘的事件监听器](./event-listener.html)
  > 为 dom 元素添加事件监听器并绑定事件处理函数，在 dom 元素销毁时不主动将事件监听器移除，其绑定的事件处理函数以及其中的变量都被认为是需要的而不会进行回收，如果内部引用的变量存储了大量数据，可能会引起页面占用内存过高，这样就造成意外的内存泄漏。
- 遗忘的 Map、Set对象
  > 当使用 Map 或 Set 存储对象时，都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。
  - [强引用](./strongly-reference.html)
  - [弱引用](./weak-reference.html)
- [未清除的 console 输出](./console.html)
  > 写代码的过程中，肯定避免不了一些输出，可能项目上线也不清理这些 console，殊不知这些 console 也是隐患，同时也是容易被忽略的，我们之所以在控制台能看到数据输出，是因为浏览器保存了我们输出对象的信息数据引用，也正是因此未清理的 console 如果输出了对象也会造成内存泄漏。

## 排查定位
### Performance
- 面板
![Performance面板](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/f0b9a9b9dcc944819f6763265094929d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)
- 页面录制
![页面录制介绍](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/3be606b37a074e3d8dd1c50b425ced43~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

### Memory
- 面板
![Memory面板](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/412621c5d4c846a2b48192aa4f2f9f33_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.image)
- 摘要：按照构造函数进行分组，捕获对象和其使用内存的情况，用于跟踪定位DOM节点的内存泄漏
  - 构造函数：显示所有的构造函数，点击每一个构造函数可以查看由该构造函数创建的所有对象
    - system、system/Context 表示引擎自己创建的以及上下文创建的一些引用，这些不用太关注，不重要
    - closure 表示一些函数闭包中的对象引用
    -  array、string、number、regexp 这一系列也能看出，就是引用了数组、字符串、数字或正则表达式的对象类型
    -  HTMLDivElement、HTMLAnchorElement、DocumentFragment等等这些其实就是你的代码中对元素的引用或者指定的 DOM 对象引用
  - 距离：显示通过最短的节点路径到根节点的距离，引用层级
  - 浅层大小：显示对象所占内存，不包含内部引用的其他对象所占的内存
  - 保留大小：显示对象所占的总内存，包含内部引用的其他对象所占的内存
- 比较：对比某个操作前后的内存快照区别，分析操作前后内存释放情况等，便于确认内存是否存在泄漏及造成原因
  - 新对象数：新建了多少个对象
  - 已删除#项：回收了多少个对象
  - 增量：新建的对象数 减去 回收的对象数
- 控制：探测堆的具体内容，提供一个视图来查看对象结构，有助分析对象引用情况，可分析闭包及更深层次的对象分析
- 统计信息：统计视图
