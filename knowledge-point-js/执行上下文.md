# 执行上下文
> js引擎在执行代码前所创建的对应代码的执行环境。一个执行上下文定义了一段可执行代码的环境，每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕时，执行上下文就会被销毁。

## 分类
> 执行上下文有且只有三类
- 全局执行上下文：全局执行上下文只有一个，是最外围的一个执行环境，在浏览器中的全局对象就是 window对象，我们能通过this直接访问到它
- 函数执行上下文：函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文；需要注意的是，**同一个函数被多次调用，都会创建一个新的上下文。**
- eval执行上下文（一般不使用，在这里暂不讨论）

## 执行上下文栈(执行栈)
> 执行上下文栈（简称执行栈）也叫调用栈，执行栈用于存储代码执行期间创建的所有上下文，具有LIFO（Last In First Out后进先出，也就是先进后出）的特性。

> JS代码首次运行，都会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内；由于执行栈LIFO的特性，所以可以理解为，JS代码执行完毕前在执行栈底部永远有个全局执行上下文。

- 执行栈的工作过程
  - 入栈: 程序执行进入一个执行环境时，它的执行上下文就会被创建，并被压入执行栈中，因此全局上下文是第一个入栈的，处于栈底
  - 执行: 处于栈顶的是当前正在执行的上下文
  - 当处于栈顶的上下文执行完后，它就会被销毁（全局上下直到应用程序退出才会被销毁），并出栈，控制权交由下一个执行上下文（如果有闭包会阻止该操作，也就是执行上下文不会被销毁）。
  
## 执行上下文的生命周期
1. 创建阶段：主要负责三件事：**确定this**---**创建词法环境组件（LexicalEnvironment）**---**创建变量环境组件（VariableEnvironment）**
   1. 确定this： 
      - 全局执行上下文中，this总是指向全局对象，例如浏览器环境下this指向window对象。
      - 函数执行上下文中，this的值取决于函数的调用方式，如果被一个对象调用，那么this指向这个对象。否则this一般指向全局对象window或者undefined（严格模式）。
   2. 创建词法环境组件：词法环境是一个包含**标识符=>变量映射**的结构，这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用。
      1. 组成：由环境记录与对外部环境引入记录两个部分组成。
         - 环境记录：用于存储当前环境中的变量和函数声明的实际位置
         - 外部环境引入记录：用于保存自身环境可以访问的其它外部环境（作用域链）
      2. 分类：
         - 词法环境组件分类：由于执行上下文分为全局执行上下文与函数执行上下文，所以这也导致了词法环境分为全局词法环境与函数词法环境两种
           - 全局词法环境组件：对外部环境的引入记录为null，因为它本身就是最外层环境，除此之外它还记录了当前环境下的所有属性、方法位置。
           - 函数词法环境组件：包含了用户在函数中定义的所有属性方法外，还包含了一个arguments对象。函数词法环境的外部环境引入可以是全局环境，也可以是其它函数环境，这个根据实际代码而来。
         - 环境记录器
           - 在函数环境中，**声明式环境记录器**存储变量、函数和参数。
           - 在全局环境中，**对象环境记录器**用来定义出现在全局上下文中的变量和函数的关系。
   3. 创建变量环境组件：变量环境可以说也是词法环境，它具备词法环境所有属性，一样有环境记录与外部环境引入。**在ES6中唯一的区别在于词法环境用于存储函数声明与let const声明的变量，而变量环境仅仅存储var声明的变量**。
2. 执行阶段：执行上下文进入执行栈后，代码开始执行，进行赋值，函数调用等操作
3. 回收阶段：当函数执行完毕后，函数执行上下文从执行栈中弹出，一旦所有代码执行完成，javaScript 引擎就从当前栈中移除全局执行上下文。

![执行栈](https://cdn.jsdelivr.net/gh/wangyi1217678365/yi-image-host/调用栈.png)
   
## 总结
1. 全局执行上下文一般由浏览器创建，代码执行时就会创建；函数执行上下文只有函数被调用时才会创建，调用多少次函数就会创建多少上下文。
2. 调用栈用于存放所有执行上下文，满足FILO规则
3. 执行上下文创建阶段分为绑定this，创建词法环境，变量环境三步，后两者的区别在于词法环境存放函数声明与const let声明的变量，而变量环境只存储var声明的变量。
4. 词法环境主要由环境记录与外部环境引入记录两个部分组成，全局上下文与函数上下文的外部环境引入记录不一样，全局为null，函数为全局环境或者其它函数环境。环境记录也不一样，全局叫对象环境记录，函数叫声明性环境记录。
5. 在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值，var声明被设置为了undefined，函数被设置为了自身函数，而let const被设置为 uninitialized [ˌʌnɪˈnɪʃəˌlaɪzd] 未初始化。现在你明白了为什么会存在变量提升，函数提升，而let const没有。
6. ES3之前的变量对象与活动对象的概念在ES5之后由词法环境，变量环境来解释，两者概念不冲突，后者理解更为通俗易懂。
7. JavaScript引擎需要用栈来维护程序执行期间的上下文的状态，如果栈空间大了的话，所有数据都存放在栈空间里面，会影响到上下文切换的效率，进而影响整个程序的执行效率。所以基本数据类型存储在栈中，引用数据类型存储在堆中
   



> [参考文档：https://juejin.cn/post/6844903682283143181#heading-4](https://juejin.cn/post/6844903682283143181#heading-4)

> [参考文档：https://juejin.cn/post/7123896578108047391#heading-5](https://juejin.cn/post/7123896578108047391#heading-5)

> [参考文档：https://www.lmonkey.com/t/OwLnAYGyg](https://www.lmonkey.com/t/OwLnAYGyg)

> [参考文档：https://www.jianshu.com/p/a789b375a7cf](https://www.jianshu.com/p/a789b375a7cf) 