# 作用域
全局作用域
函数作用域
块级作用域
# 作用域链
> 在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。

## 静态作用域链
> 嵌套关系是分析代码就可以得出的，不需要运行，按照这种顺序访问变量的链就是静态作用域链，这种链的好处是可以直观的知道变量之间的引用关系。

## 动态作用域链
> 作用域的引用关系与嵌套关系无关，与执行顺序有关，会在执行的时候动态创建不同函数、块的作用域的引用关系。缺点就是不直观，没法静态分析。
```
function func () {
  const a = 1;
  return function () {
    console.log(a);
  }
}
const f2 = func();
```
这就导致了一个问题，本来按照顺序创建调用一层层函数，按顺序创建和销毁作用域挺好的，但是如果内层函数返回了或者通过别的暴露出去了，那么外层函数销毁，内层函数却没有销毁，这时候怎么处理作用域，父作用域销不销毁？

# 闭包

> 是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

## 设计闭包
销毁父作用域后，把用到的变量包起来，打包给子函数，放到一个属性上。这就是闭包的机制。

## 词法作用域
```
  function init() {
    var name = "Mozilla"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
  }
  init();
```
> 这里displayName函数可以访问到init函数中的name是因为displayName是init函数中声明的函数，他们存在嵌套关系，也就是存在作用域的嵌套关系，跟据变量访问规则可知：在当前作用域中访问一个变量，如果变量不存在那么会根据作用域链，从当前作用域的上级作用域中查找该变量直到全局作用域。

## 闭包
```
  function makeFunc() {
      var name = "Mozilla";
      function displayName() {
          alert(name);
      }
      return displayName;
  }

  var myFunc = makeFunc();
  myFunc();
```
> 跟据执行栈LIFO的特性可知，makeFunc函数执行完毕后，所创建的函数执行上下文会出栈，然后声明变量myFunc并赋值displayName函数的引用地址，执行myFunc函数，创建displayName的执行上下文压入执行栈执行。按照这个思路，由于makeFunc执行上下文已经销毁，displayName函数执行时应该访问不到上级作用域makeFunc中的变量

> 为什么可以访问？因为JavaScript中的函数形成了闭包。**闭包是由外部函数通过 ast 语法树检查内部函数是否引用自身变量，从而创建闭包。闭包仅包含被引用的变量。**在本例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用。displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到alert中。

## 生成闭包的条件

1. 函数内部声明函数
2. 被声明函数引用上级函数作用中的变量
3. 函数return内部声明的函数

## 闭包性能

> 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。

> 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。

> [参考文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

> [参考文档：https://juejin.cn/post/6957913856488243237#comment](https://juejin.cn/post/6957913856488243237#comment)
