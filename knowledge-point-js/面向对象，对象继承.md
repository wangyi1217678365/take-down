# 面向对象
> 一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：

1. 工厂模式：工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。
    ```
      function fun (name, age) {
          return {
              name,
              age
          }
      }
    ```
2. 构造函数模式：js 中除了箭头函数外每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是引用数据类型，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。
  - 优点：所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型
  - 缺点：造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。
    ```
      function fun (name, age) {
          this.name = name
          this.age = age
          this.get = function () {}
      }
      const obj = new fun('王', '18') 
      const obj2 = new fun('王1', '22') 
    ```
3. 原型模式：因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。
  - 优点：解决了函数对象的复用问题
  - 缺点：无法通过传入参数来初始化值，还有就是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。
    ```
      function fun (name, age) {}
      fun.prototype.get = function () {}
      fun.prototype.arr = [1, 2, 3]
      const obj1 = new fun()
      const obj2 = new fun()
      obj1.__proto__.arr[0] = 110 
      console.log(obj2.__proto__.arr[0]) // 110
    ```
4. 混合模式：使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。
   - 缺点：如果通过原型公用一个引用类型如 Array 这样的值，那么一个实例对引用类型值的改变会影响所有的实例。
    ```
      function fun (name, age) {
        this.name = name
        this.age = age
      }
      fun.prototype.getName = function () {
        return this.name
      }
      const obj1 = new fun('w', 18)
      const obj2 = new fun('w1', 19)
      /*
        这样创建出来的对象都可以通过构造函数来初始化并且通过原型访问公共实行或方法。
      */ 
    ```

# 对象继承

1. 原型链继承：以原型链的方式来实现继承
   - 缺点：在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向父类构造函数传递参数。
    ```
      function parent () {
        this.age = 18
      }
      parent.prototype.getName = function () {
        return this.name
      }
      function child (name) {
        this.name = name
      }
      /*
        通过改变子类构造函数的原型，可以使得创建出的子类实例对象的原型指向父类的的实例对象
      */ 
      child.prototype = new parent()
      /*
        由于改变了子类构造函数的原型，所以访问子类原型上的constructor时实际上访问的是父类的实例对象的原型上的constructor，也就是父类构造函数，所以需要将constructor指回自己。
      */ 
      child.prototype.constructor = child
      const childObj = new child('www')
    ```

2. 构造函数继承：通过在子类型的函数中调用父类构造函数并改变其this指向来实现的
   - 优点：解决了不能向父类构造函数传递参数的缺点
   - 缺点：无法实现函数方法的复用，并且父类原型定义的方法子类型也没有办法访问到
    ```
      function parent () {
        this.age = 18 
      }
      parent.prototype.getName = function () {
        return this.name
      }

      function child (name) {
        parent.call(this)
        this.name = name
      }
      const childObj = new child('www')
      /*
        通过在子类构造函数中调用父类构造函数并改变其this指向来实现继承父类构造函数中的属性跟方法
      */ 
    ```

3. 组合模式：将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为父类构造函数的实例来实现方法的继承。
   - 缺点：调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。
  
4. 原型式继承：基于已有的对象来创建新的对象。实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。**ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。**
