# 作用域
> 作用域是当前的执行上下文，值和表达式在其中“可见”或可被访问。如果一个变量或表达式不在当前的作用域中，那么它是不可用的。作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。作用域主要用来隔离变量，不同作用域下同名变量不会有冲突。

## 分类

### 全局作用域
> 在代码中任何地方都能访问到的对象拥有全局作用域，容易污染全局命名空间, 引起命名冲突。
- 一般来说以下几种情形拥有全局作用域
  - 最外层函数 和在最外层函数外面定义的变量拥有全局作用域
  - 所有末定义直接赋值的变量自动声明为拥有全局作用域
  - 所有window对象的属性拥有全局作用域

### 函数作用域
> 是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。作用域是层级结构的，内层作用域可以访问外层作用域的变量，反之则不行。

### 块级作用域
> 块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。
- 块级作用域在如下情况被创建
  - 在一个函数内部
  - 在一个代码块（由一对花括号包裹）内部
- 特点
  - 生成块级作用域
  - let / const 声明变量不会像 var 一样提升到代码块顶部
  - let / const 禁止在同一个作用域内重复声明同一个变量
  - 存在暂时性死区，即在使用let、const命令声明变量之前，该变量都是不可用的
  - let 可以改变变量的指针，const 不可以
  - let 不需要设置初始值，const 必须设置

## 作用域链
> 在 JavaScript 里面，函数、块、都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。在作用域中变量的访问规则会跟据作用域链进行查找。

### 静态作用域链
> 嵌套关系是分析代码就可以得出的，不需要运行，按照这种顺序访问变量的链就是静态作用域链，这种链的好处是可以直观的知道变量之间的引用关系。

### 动态作用域链
> 作用域的引用关系与嵌套关系无关，与执行顺序有关，会在执行的时候动态创建不同函数、块的作用域的引用关系。缺点就是不直观，没法静态分析。
```
function func () {
  const a = 1;
  return function () {
    console.log(a);
  }
}
const f2 = func();
```
这就导致了一个问题，本来按照顺序创建调用一层层函数，按顺序创建和销毁作用域挺好的，但是如果内层函数返回了或者通过别的暴露出去了，那么外层函数销毁，内层函数却没有销毁，这时候怎么处理作用域，父作用域销不销毁？答案是闭包机制。

> [参考文档：https://juejin.cn/post/6844903797135769614](https://juejin.cn/post/6844903797135769614)


# 闭包
> 是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

## 形成条件
> 内部函数保持了对外层作用域中变量的引用，那么就会形成闭包。闭包是由外层函数创建的，闭包会被作用域中嵌套的函数共享。

## 作用
- 保护：保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；
- 保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；

## 解决了什么问题
- 正常访问变量
```
  function init() {
    var name = "Mozilla"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
  }
  init();
```
> 这里displayName函数可以访问到init函数中的name是因为displayName是init函数中声明的函数，他们存在嵌套关系，也就是存在作用域的嵌套关系，跟据变量访问规则可知：在当前作用域中访问一个变量，如果变量不存在那么会根据作用域链，从当前作用域的上级作用域中查找该变量直到全局作用域。

- 形成闭包，访问已销毁的上级作用域中的变量
```
  function makeFunc() {
      var name = "Mozilla";
      function displayName() {
          alert(name);
      }
      return displayName;
  }

  var myFunc = makeFunc();
  myFunc();
```
> 跟据执行栈LIFO的特性可知，makeFunc函数执行完毕后，所创建的函数执行上下文会出栈，然后声明变量myFunc并赋值displayName函数的引用地址，执行myFunc函数，创建displayName的执行上下文压入执行栈执行。按照这个思路，由于makeFunc执行上下文已经销毁，displayName函数执行时应该访问不到上级作用域makeFunc中的变量

> 为什么可以访问？因为JavaScript中的函数形成了闭包。**闭包是由外部函数通过 ast 语法树检查内部函数是否引用自身变量，从而创建闭包。闭包仅包含被引用的变量。**在本例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用。displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到alert中。

## 闭包性能

> 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。

> 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。

## 内存泄漏
> 由于闭包会建立一个对不会被浏览器 CG 的内存的引用关系，造成了内存泄漏。一般通过将利用闭包访问的变量的引用关系置空取消对内存的引用，这样浏览器就可以回收掉这块内存。

> [参考文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
> [参考文档：https://juejin.cn/post/6957913856488243237#comment](https://juejin.cn/post/6957913856488243237#comment)
> [参考文档：https://juejin.cn/post/6844903858636849159#heading-4](https://juejin.cn/post/6844903858636849159#heading-4)

# 执行上下文
> js引擎在执行代码前所创建的对应代码的执行环境。一个执行上下文定义了一段可执行代码的环境，每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕时，执行上下文就会被销毁。

## 分类
> 执行上下文有且只有三类
- 全局执行上下文：全局执行上下文只有一个，是最外围的一个执行环境，在浏览器中的全局对象就是 window对象，我们能通过this直接访问到它
- 函数执行上下文：函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文；需要注意的是，**同一个函数被多次调用，都会创建一个新的上下文。**
- eval执行上下文（一般不使用，在这里暂不讨论）

## 执行上下文栈(执行栈)
> 执行上下文栈（简称执行栈）也叫调用栈，执行栈用于存储代码执行期间创建的所有上下文，具有LIFO（Last In First Out后进先出，也就是先进后出）的特性。

> JS代码首次运行，都会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内；由于执行栈LIFO的特性，所以可以理解为，JS代码执行完毕前在执行栈底部永远有个全局执行上下文。

- 执行栈的工作过程
  - 入栈: 程序执行进入一个执行环境时，它的执行上下文就会被创建，并被压入执行栈中，因此全局上下文是第一个入栈的，处于栈底
  - 执行: 处于栈顶的是当前正在执行的上下文
  - 当处于栈顶的上下文执行完后，它就会被销毁（全局上下直到应用程序退出才会被销毁），并出栈，控制权交由下一个执行上下文（如果有闭包会阻止该操作，也就是执行上下文不会被销毁）。
  
## 执行上下文的生命周期
1. 创建阶段：主要负责三件事：**确定this**---**创建词法环境组件（LexicalEnvironment）**---**创建变量环境组件（VariableEnvironment）**
   1. 确定this： 
      - 全局执行上下文中，this总是指向全局对象，例如浏览器环境下this指向window对象。
      - 函数执行上下文中，this的值取决于函数的调用方式，如果被一个对象调用，那么this指向这个对象。否则this一般指向全局对象window或者undefined（严格模式）。
   2. 创建词法环境组件：词法环境是一个包含**标识符=>变量**的映射结构，这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用。
      1. 组成：由环境记录与对外部环境引入记录两个部分组成。
         - 环境记录：用于存储当前环境中的变量和函数声明的实际位置
           - 在全局环境中，**对象环境记录器**用来定义出现在全局上下文中的变量和函数的关系。
           - 在函数环境中，**声明式环境记录器**存储变量、函数和参数，还包含了一个arguments对象。
         - 外部环境引入记录：用于保存自身环境可以访问的其它外部环境（作用域链）
      2. 分类：
         - 词法环境组件分类：由于执行上下文分为全局执行上下文与函数执行上下文，所以这也导致了词法环境分为全局词法环境与函数词法环境两种
           - 全局词法环境组件：
             - 外部环境引入记录：对外部环境的引入记录为null，因为它本身就是最外层环境，
             - 环境记录：对象环境记录器。
           - 函数词法环境组件：
             - 外部环境引入记录：可以是全局环境，也可以是其它函数环境，这个根据实际代码而来。（作用域链）
             - 环境记录：声明式环境记录器
           
   3. 创建变量环境组件：变量环境可以说也是词法环境，它具备词法环境所有属性，一样有环境记录与外部环境引入。**在ES6中唯一的区别在于词法环境用于存储函数声明与let const声明的变量，而变量环境仅仅存储var声明的变量**。
2. 执行阶段：执行上下文进入执行栈后，代码开始执行，进行赋值，函数调用等操作
3. 回收阶段：当函数执行完毕后，函数执行上下文从执行栈中弹出，一旦所有代码执行完成，javaScript 引擎就从当前栈中移除全局执行上下文。

![执行栈](https://jsdelivr.codeqihan.com/gh/wangyi1217678365/yi-image-host/调用栈.png)
   
## 总结
1. 全局执行上下文一般由浏览器创建，代码执行时就会创建；函数执行上下文只有函数被调用时才会创建，调用多少次函数就会创建多少上下文。
2. 调用栈用于存放所有执行上下文，满足FILO规则
3. 执行上下文创建阶段分为绑定this，创建词法环境，变量环境三步，后两者的区别在于词法环境存放函数声明与const let声明的变量，而变量环境只存储var声明的变量。
4. 词法环境主要由环境记录与外部环境引入记录两个部分组成，全局上下文与函数上下文的外部环境引入记录不一样，全局为null，函数为全局环境或者其它函数环境。环境记录也不一样，全局叫对象环境记录，函数叫声明性环境记录。
5. 在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值，var声明被设置为了undefined，函数被设置为了自身函数，而let const被设置为 uninitialized [ˌʌnɪˈnɪʃəˌlaɪzd] 未初始化。现在你明白了为什么会存在变量提升，函数提升，而let const没有。
6. ES3之前的变量对象与活动对象的概念在ES5之后由词法环境，变量环境来解释，两者概念不冲突，后者理解更为通俗易懂。
7. JavaScript引擎需要用栈来维护程序执行期间的上下文的状态，如果栈空间大了的话，所有数据都存放在栈空间里面，会影响到上下文切换的效率，进而影响整个程序的执行效率。所以基本数据类型存储在栈中，引用数据类型存储在堆中
   
> [参考文档：https://juejin.cn/post/6844903682283143181#heading-4](https://juejin.cn/post/6844903682283143181#heading-4)

> [参考文档：https://juejin.cn/post/7123896578108047391#heading-5](https://juejin.cn/post/7123896578108047391#heading-5)

> [参考文档：https://www.lmonkey.com/t/OwLnAYGyg](https://www.lmonkey.com/t/OwLnAYGyg)

> [参考文档：https://www.jianshu.com/p/a789b375a7cf](https://www.jianshu.com/p/a789b375a7cf) 